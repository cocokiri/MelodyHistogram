<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>PITCHINTIME</title>
    <link rel="stylesheet" href="./style/styling.css">

    <script src="../MyFunctions/SwagLib.js"></script>
    <script src="./Victor.js"></script>
</head>

<canvas></canvas>

<script>
    'use strict'
    window.addEventListener("onload", init);

    const framesPerAnim = 300;
    const CANV = document.querySelector('canvas');
    // // console.log(CANV);
    let CX = CANV.getContext("2d");

    window.onload = resizeCanvas(CANV);
    window.onresize = resizeCanvas(CANV);

    let timer = 0;
    let FPS = 0;
    let TIMING = {
        now: new Date().getTime(),
        previousTime: new Date().getTime(),
        deltaTime: 0,
        fps: 0
    }

    let points = [{
        pos: new Victor(1,1),
        timing: 0
    }];

    points[1] = {
        pos: new Victor(5, 4),
        timing: 1
    };
    points[2] = {
        pos: new Victor(8, 0),
        timing: 2
    };
    points[3] = {
        pos: new Victor(12, 0),
        timing: 3
    };

    const NOTE_RANGE = 12;
    const TIMEHORIZON = 20; //seconds
    let heightUnit = CANV.height / NOTE_RANGE; //if 12 notes --- 1/12 of screenheight
    let widthUnit = CANV.width / TIMEHORIZON;
    let fromPoint = points[0].pos;


    console.log(CANV.height);
    console.log(points);
    console.log(TIMING);

    init();

    function init() {
        'use strict'
        // CX.beginPath();
        // CX.moveTo(points[0].pos.x * widthUnit, (points[0].pos.y + 2) * heightUnit);
        // CX.lineTo(points[1].pos.x * widthUnit, (points[1].pos.y + 2) * heightUnit);
        // CX.strokeStyle = "black";
        // CX.lineWidth = 3;
        // CX.stroke();
        // console.log(CX);
        // CX.closePath();

        loop();
    }

    Victor.prototype.midiToUnitVector = function(midi) {
        let rad = (midi % 12) / 12 * Math.PI * 2;
        let x = Math.sin(rad); //x of einheitskreis
        let y = -Math.cos(rad); //y of einheitsKreis
        let vec = new Victor(x, y);
        return vec;
    }

    function loop() {
        TIMING.now = new Date().getTime();
        TIMING.deltaTime = TIMING.now - TIMING.oldTime;
        TIMING.previousTime = TIMING.now;
        TIMING.fps = 1000 / TIMING.deltaTime;


        let fromPoint =  new Victor(points[0].pos.x, points[0].pos.y);
        let toPoint = new Victor(points[1].pos.x, points[1].pos.y);; //readd Victor functionality

        let VecDir = toPoint.subtract(fromPoint);
        let perFrameVec = VecDir.divide(new Victor(framesPerAnim, framesPerAnim)); //= divide by 300
        // console.log(perFrameVec);
        //frames animated * totalvector/totalframes + wherewestarted
        let currentPoint = fromPoint.add(perFrameVec.multiply(new Victor(timer, timer)));
        // console.log(currentPoint);


        //RENDER
        if (timer === 0) {
            console.log(timer);
            CX.beginPath();
            CX.moveTo(fromPoint.x * widthUnit, CANV.height - fromPoint.y * heightUnit);
        } else {
            CX.lineTo(currentPoint.x * widthUnit, CANV.height- currentPoint.y * heightUnit);
        }
        CX.stroke();

        if(timer >= framesPerAnim) {
            timer = 0;
            points.shift(); //remove first item...next couple of Vecs
        }

        timer++;
        requestAnimationFrame(loop);
    }

    // function CoordsInPx ()


    //when to switch to the next point

    // directionalVector = VecA.subtract(VecB); -> divide by (new Victor(frames,frames)) = /100 or  x y
    //==> add directVec to lineTo Path every Frame....maybe some easing but who gives
    //decide if to switch when ...distance is close or frames have passed.

    //model.update();
    //ui.draw();

</script>
